// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_preferences.sql

package database

import (
	"context"
	"encoding/json"
)

const addFavoriteFlow = `-- name: AddFavoriteFlow :one
INSERT INTO user_preferences (user_id, preferences)
VALUES (
  $1::bigint,
  jsonb_build_object('favoriteFlows', jsonb_build_array($2::bigint))
)
ON CONFLICT (user_id) DO UPDATE
SET preferences = jsonb_set(
  user_preferences.preferences,
  '{favoriteFlows}',
  CASE
    WHEN user_preferences.preferences->'favoriteFlows' @> to_jsonb($2::bigint) THEN
      user_preferences.preferences->'favoriteFlows'
    ELSE
      user_preferences.preferences->'favoriteFlows' || to_jsonb($2::bigint)
  END
)
RETURNING id, user_id, preferences, created_at, updated_at
`

type AddFavoriteFlowParams struct {
	UserID int64 `json:"user_id"`
	FlowID int64 `json:"flow_id"`
}

func (q *Queries) AddFavoriteFlow(ctx context.Context, arg AddFavoriteFlowParams) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, addFavoriteFlow, arg.UserID, arg.FlowID)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserPreferences = `-- name: CreateUserPreferences :one
INSERT INTO user_preferences (
  user_id,
  preferences
) VALUES (
  $1,
  $2
)
RETURNING id, user_id, preferences, created_at, updated_at
`

type CreateUserPreferencesParams struct {
	UserID      int64           `json:"user_id"`
	Preferences json.RawMessage `json:"preferences"`
}

func (q *Queries) CreateUserPreferences(ctx context.Context, arg CreateUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, createUserPreferences, arg.UserID, arg.Preferences)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFavoriteFlow = `-- name: DeleteFavoriteFlow :one
UPDATE user_preferences
SET preferences = jsonb_set(
  preferences,
  '{favoriteFlows}',
  (
    SELECT COALESCE(jsonb_agg(elem), '[]'::jsonb)
    FROM jsonb_array_elements(preferences->'favoriteFlows') elem
    WHERE elem::text::bigint != $1::bigint
  )
)
WHERE user_id = $2::bigint
RETURNING id, user_id, preferences, created_at, updated_at
`

type DeleteFavoriteFlowParams struct {
	FlowID int64 `json:"flow_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteFavoriteFlow(ctx context.Context, arg DeleteFavoriteFlowParams) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, deleteFavoriteFlow, arg.FlowID, arg.UserID)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserPreferences = `-- name: DeleteUserPreferences :exec
DELETE FROM user_preferences
WHERE user_id = $1
`

func (q *Queries) DeleteUserPreferences(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserPreferences, userID)
	return err
}

const getUserPreferencesByUserID = `-- name: GetUserPreferencesByUserID :one
SELECT id, user_id, preferences, created_at, updated_at FROM user_preferences
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserPreferencesByUserID(ctx context.Context, userID int64) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, getUserPreferencesByUserID, userID)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPreferences = `-- name: UpdateUserPreferences :one
UPDATE user_preferences
SET preferences = $2
WHERE user_id = $1
RETURNING id, user_id, preferences, created_at, updated_at
`

type UpdateUserPreferencesParams struct {
	UserID      int64           `json:"user_id"`
	Preferences json.RawMessage `json:"preferences"`
}

func (q *Queries) UpdateUserPreferences(ctx context.Context, arg UpdateUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, updateUserPreferences, arg.UserID, arg.Preferences)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserPreferences = `-- name: UpsertUserPreferences :one
INSERT INTO user_preferences (
  user_id,
  preferences
) VALUES (
  $1,
  $2
)
ON CONFLICT (user_id) DO UPDATE
SET preferences = EXCLUDED.preferences
RETURNING id, user_id, preferences, created_at, updated_at
`

type UpsertUserPreferencesParams struct {
	UserID      int64           `json:"user_id"`
	Preferences json.RawMessage `json:"preferences"`
}

func (q *Queries) UpsertUserPreferences(ctx context.Context, arg UpsertUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, upsertUserPreferences, arg.UserID, arg.Preferences)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
